#include <iostream>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <semaphore.h>
#include <sys/wait.h>
#include <random>
#include <string>
#include <time.h>

// В турнире может быть максимум 100 участников (рандомная генерация четного числа)
// Будет лежать vector длины n в разделяемой памяти и по завершению матча между двумя игроками у победителя будет true
// Также будет лежать счетчик людей, которые остались в турнире.
// Турнир будет идти пока этот счетчик не равен 1
// По завершению программы она выведет номер участника-победителя

// Программа создаст n процессов. Каждый процесс имеет свой мьютекс. В режиме ожидания он берет процесс с разблокированным мьютексом и блокирует его,
// аналогично делает процесс, которого взял первый процесс. Начинается игра между ними: каждый  процесс генерирует число от 0 до 2 и затем 
// в двух процессах происходит сравнение результата - проигравший процесс отмечает в векторе процессов, что он выбыл, разблокирУет мьютекс второго процесса
// и завершает работу.
// Выигравший процесс становится снова разблокированным и разблокирует и удаляет семафор проигравшего процесс для избежания утечек памяти.
// После вывода победителя его семафор тоже удаляется.

// есть два вектора - один с текущим состоянием турнира (кто выиграл, кто проиграл).
// Второй будет использоваться для обозначения кто с кем играет.
// каждый процесс сканирует этот вектор и если он находит процесс с отсутствующим соперником то он начинает с ним игру путем блокировки семафора с номером игрока в векторе 
// и в векторе для двух процессов ставится то что они играют друг с другом.
// Во время игры создается разделяемая память и в нее записываются сгенерированные процессами значения. Это продолжается пока значения равны. 
// Затем определяется результат игры и разделяемая память удаляется.

// Если именнованые семафоры то они названы одинаково + номер игрока и используется только номер для доступа к ним
// Если семафоры неименнованные то они создаются до процессов и поочереди расталкиваются в процессы

#define STATE_SEM "/tournament_state"
#define PLAYER_SEM "/player_"


struct TournamentState {
    int winner;
    int remaining;
    int opponents[100];
    bool state[100];
};

// 0 - камень, 1 - ножницы, 2 - бумага
int referee(int p1, int p2, int v1, int v2) {
    if (v1 == 0 && v2 == 1 || v1 == 1 && v2 == 2 || v1 == 2 && v2 == 0) {
        return p1;
    }
    return p2;
};


void players_routine(int player_number) {
    std::string sem_name = PLAYER_SEM + std::to_string(player_number);
}


int main() {
    int n = rand() % 100;

    TournamentState* state = new TournamentState();

    state->winner = -1;
    state->remaining = n;

    for (int i = 0; i < n; i++) {
        state->opponents[i] = -1;
        state->state[i] = false;
    }

    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    ftruncate(shm_fd, sizeof(TournamentState));
    
    TournamentState* tournament_state = (TournamentState*)mmap(
        NULL, sizeof(TournamentState), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);




    return 0;
}